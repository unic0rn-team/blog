---
title: "CVE-2022-30190 \"Follina\" - part 2"
date: 2022-07-01
author: "Hugo Contributors"
---



## # Billet 2



### **TL-DR;**

Suite à la publication de l'existence de la 0-Day, des POC (démonstrateurs) validant son exploitabilité ont commencés à être publiés rapidement. Comme pour toutes les vulnérabilités critiques, il convient de tester ceux-ci afin de valider leur exploitabilité et leur pertinence par rapport à l'environnement opérationnel.

## 	2.POCs à surprises



Le système cible pour nos tests est un Windows 10 Professionnel x64 version 21H1 avec MS Office 2016. Pour notre banc d'essai on a décidé de choisir le démonstrateur publié par [John Hammond](https://github.com/JohnHammond/msdt-follina) (HuntressLab) qui a l'avantage de pouvoir tester plusieurs scénarios d'exploitation. 

#### a. Scénario 1 (kill-chain initial)

Il s'agit ici de tester la vulnérabilité tel qu'elle à été découverte. Pour cela, le script, écrit en Python, remplace au sein du document Word porteur ("carrier") la charge malveillante ("payload") par l'exécution d'un programme inoffensif : **calc.exe**.  Il lancera ensuite un serveurs HTTP léger (*SimpleHTTPServer*) sur le port 8000 pour mimer le serveur C2 de l'attaquant. 

Son utilisation est très simple :

![](/img/img9.png)



Après avoir copié le document Word ainsi généré sur la machine cible on ouvre celui-ci. Après nous avoir affiché l'écran de l'utilitaire msdt, il lancera le calculateur :

![](/img/img12.png) 

La communication avec le serveur est confirmé aussi :

![](/img/img13.png)

Pour valider son comportement générique on relance le test en invoquant un autre binaire bénigne : **notepad.exe** avec, sans surprise, un résultat identique :

![](/img/img14.png)

![](/img/img15.png)

L'exploit etant parfaitement reproductible on confirme ainsi l'existence de la vulnérabilité dans notre environnement. Pour tester son exploitabilité distante, le démonstrateur nous met à la disposition la possibilité d'injecter netcat (**nc.exe**) et d'invoquer ainsi un "reverse shell" avec la cible sur le port 9001 :

![](/img/img17.png)

Le résultat est concluant :  tandis que sur la cible s'affiche le pop-up msdt sur le serveur de l'attaquant on obtient un shell et on atterrit sur la machine en tant que **administrateur local** à la ligne de commande:

![](/img/img18.png)

![](/img/img19.png)

Il n'est pas un hasard qu'on ouvre la session dans le répertoire temporaire **SDIAG**. Ceci est liée au [mode de création des archives](https://irsl.medium.com/the-trouble-with-microsofts-troubleshooters-6e32fc80b8bd) .cab qui contiennent les informations de dépannage en cas d'incident : initialement  situés dans le repertoire *%WINDIR%\Diagnostics* elles sont considérés comme valides sans autre vérification, tout le reste etant soumis à la vérification de la signature. Avant de vérifier la signature, l'implémentation du protocole msdt effectue une copie locale du répertoire référencé vers un repertoire de destination temporaire aléatoire, du type "*C:\Users\John Doe\AppData\Local\Temp\**SDIAG**_0636db01-fabd-49ed-bd1d-b3fbbe5fd0ca*". A noter que ce chemin a un nombre statique de composants, ce qui rendra l'attaque déterministe.

La criticité de la vulnérabilité vient ainsi d'être validé . Par ailleurs, après l'application de la [mise à jour de Microsoft](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2022-30190) (ou des [contournements recommandés](https://www.pwndefend.com/2022/05/30/office-microsoft-support-diagnostic-tool-msdt-vulnerability-follina/)) on confirme que celle-ci n'est plus exploitable dans ce contexte.



#### **b. Scénario 2 (kill-chain RTF)**

Dans les stages initiales de l'analyse plusieurs chercheurs ont indiqué que l'utilisation du mode protégé ("[Protected View](https://support.microsoft.com/en-us/topic/what-is-protected-view-d6f09ac7-e6b9-4495-8e43-2bbcdbcb6653)") de MS Office bloquerait l'exploitation de la vulnérabilité. En voulant confirmer cela ils ont essayé de trouver des chemins d'exécution différentes qu'ils ont rapidement trouvé en passant du format **.doc** (Word) au format **.rtf** (Rich Text Format). Il convient donc de valider aussi ce vecteur d'attaque.

Pour cela on a simplement ouvert le fichier Word généré par le démonstrateur en le sauvegardant en format RTF :

![](/img/img20.png)



On met notre serveur à l'écoute comme pour le premier scénario :

![](/img/img21.png)



Dans le répertoire ou se trouve notre fichier .rtf on active le paneau de previsualisation et on choisit le fichier sans l'ouvrir :

![](/img/img22.png)



![](/img/img23.png)



Contre toute attente, on remarque une requète sur le serveur et la charge est, encore une fois exécutée :

![](/img/img25.png)

![](/img/img24.png)



Quelles sont les conséquences de l'abus de ce noveau vecteur d'attaque ? En principal :

- l'exécution distante du code en 1-click ("1-click RCE") se tranforme en une **exécution distante en 0-click** ("O-click RCE") donc sans intervention de la victime
- on s'affranchit de exécution avec des **composants MS Office** - la vulnérabilité devenant ainsi générique
- le correctif publié par Microsoft n'adresse pas ce vecteur d'attaque - en effet, à l'heure actuelle, il n'y a **pas de patch publié**, alors que plusieurs échantillons d'exploitation réele (ITW) sont déjà disponibles

Pour comprendre le méchanisme d'exploitation on a, justement, récupéré un de ces fichiers RTF disponibles : **aaa.rtf** ([e8f0a2f79a91587f1d961d6668792e74985624d652c7b47cc87367cb1b451adf](https://www.virustotal.com/gui/file/e8f0a2f79a91587f1d961d6668792e74985624d652c7b47cc87367cb1b451adf/detection)).

Le format de fichier RTF à été très souvent exploité auparavant, en abusant sa fonctionnalité de conteneur qui peut intégrer d'autres fichiers à l'aide de la fonction **OLE** ("Object Linking and Embedding")  -liaison et d'intégration d'objets - utilisé pour armer ce type de documents. Les documents RTF sont donc connus pour diffuser des logiciels malveillants en intégrant des scripts via des objets OLE, puis en utilisant des schémas de nommage intélligente ("**monikers**") pour déposer des fichiers dans le répertoire souhaité, puis les exécuter.

Les monikers (sobriquets) sont une façon standardisé et extensible de nommer et connecter des objets entre eux. Plus simplement un moniker est un objet qui identifie un autre objet. Si notre fichier contienne des liens vers un objet externe l'**URLMoniker** doit être présent pour l'instantialiser. Notre tâche consiste donc en sa mise en évidence.

On commence par visualiser la structure du document ou on trouve immédiatement un objet qui contient un URL :

![](/img/img32.png)

![](/img/img33.png)

L'URL en question : hxxp://109.248.59.74/a.html pointe vers une adresse IP en Russie.

![](/img/img34.png)

Si on veut voir l'ensemble des objets intégrés dans le fichier on obtient :

![](/img/img35.png)

On isole le premier objet (OLE2Link) - tous les objets intégrés sont représentés au format OLE2- qui contienne trois streams :

![](/img/img36.png)

![](/img/img37.png)

![](/img/img38.png)

Seulement les deux premiers embarquent l'URL ( qu'on peut isoler par la suite ):

![](/img/img39.png)



![](/img/img40.png)



![](/img/img41.png)



Chaque objet [OLE incorporé](https://danusminimus.github.io/2022/06/18/Understanding-OLE-Objects-and-Microsoft-Magic-to-mess-with-with-CVE-2022-30190(Follina).html) dans un fichier RTF est enregistré dans la base de registres avec son identificateur de classe (Class ID - **CLSID** - identificateur unique pour tout composant Windows). En pratique toute entrée dans la base de régistres pour un composant se trouve d'habitude stocké dans la clef HKEY_CLASSES_ROOT\CLSID\\{valeur CLSID\}.

Cela veut dire qu"en récupérent la valeur CLSID de notre objet on peut identifié l'URL Moniker associé :

![](/img/img42.png)



On peut donc envisager comme mécanisme le plus probable d'exécution l'enchaînement suivant :

A l'activation du document RTF en le sélectionnant dans le panneau de prévisualisation, l'[URL Moniker](https://docs.microsoft.com/en-us/windows/win32/api/objidl/nf-objidl-imoniker-bindtoobject) instantialise (à travers **urlmon.dll** qui est son serveur enregistré) l'objet COM et la connexion est établie avec la ressource externe. Les détails sur la façon dont URL Moniker est exécuté et un algorithme pour déterminer les gestionnaires de protocole appropriés à invoquer (dans notre cas ms-msdt) sont décrits par [Microsoft](https://docs.microsoft.com/en-us/windows/win32/api/objidl/nf-objidl-imoniker-bindtoobject). Faute de contrôles en place le fichier **a.html** est ainsi téléchargé et le code executé par le moteur **explorer.exe** dans la deuxième étape du kill-chain.



### **c. Scénario 3 (kill-chain wget)**



L'analyse de l'exploit initial à mis en évidence le fait que la deuxième étape de l'attaque (second stage) est déclenché en mémoire par une commande PowerShell obfusqué en base64. La question de savoir si on ne peut pas récupérer et faire exécuter directement le fichier html sans passer par un porteur (carrier) tel que Word or RTF avec l'aide du PowerShell s'est donc vite posée.

Pour tester cette hypothèse on a crée un fichier **index.html** qui contient l'exploit  initial, comme suit :

![](/img/img27.png)

On a positionné celui-ci a la racine du serveur HTTP utilisé pour le démonstrateur qu'on à lancé sur le port 8000 :

![](/img/img28.png)

Sur la machine "victime" dans une console PowerShell on à utilisé wget pour le récupérer :

![](/img/img29.png)

Etonnamment la charge est exécute sans intervention et la calculatrice est lancée :

![](/img/img30.png)

Ceci est un comportement anormal, car wget est censé simplement télécharger le fichier et pas l'executer.

Tous ces testes confirment à la fois la criticié réele de cette vulnérabilité mais aussi la fragilité de l'ecosystème logiciel sous Windows.



![](/img/img43.png)



A suivre...
